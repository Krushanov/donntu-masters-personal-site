<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Resume - Research methods for creating productive database management systems - Alexander Krushanov</title>
    <link rel="stylesheet" type="text/css" href="../css/master_style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
</head>

<body lang="en">

    <div id="navigationblock">

        <div id="topblock">
            <div id="langbox">
                <a href="index.html"><img src="../images/ru.png" alt="Русский" title="Русский" width="24" height="20"></a> &nbsp; 
                <a href="indexu.html"><img src="../images/ua.png" alt="Українська" title="Українська" width="24" height="20"></a> &nbsp;
            </div>
            <div id="donntu">
                <a href="http://donntu.org/index.php?lang=eng" target="_blank">DonNTU</a> &nbsp;
                <a href="http://masters.donntu.org/indexe.html" target="_blank" title="Navigate to Masters' portal">Masters' portal</a>
            </div>
        </div> <!-- topblock --> 

        <div id="header">
            <div id="photomag">
                <a href="../krushanov_big.jpg">
                    <img src="../photo.jpg" width=180 height=240 title="DonNTU Master Alexander Krushanov"
                                         alt="DonNTU Master Alexander Krushanov">
                </a>
            </div>
            <div id="headertext">
                <h1 class="hdr">Alexander Krushanov</h1>
                <h3 class="hdr"><a href="http://cs.donntu.org" target="_blank">Faculty of Computer Science and Technology</a>
                </h3>
                <h3 class="hdr"><a href="http://pi.donntu.org" target="_blank">Department of Software Engineering</a></h3>
                <h3 class="hdr">Speciality <q>Software Engineering</q></h3>
                <h2 class="hdr">Counting the effectiveness and reliability of relational databases. Modeling system
                    clusters</h2>
                <h3 class="hdr">Scientific adviser: Ph.D., Associate Professor Victor Grishchenko</h3>
            </div>
        </div> <!-- header -->

    </div>

    <div id="middleblock">
        <div class="menu-container">
            <div class="menu-wrapper">
                <div id="menu">
                    <li>
                        <a class="button color" href="../indexe.html">Resume</a>
                    </li>
                    <li>
                        <a class="button colorfix">Abstract</a>
                    </li>
                </div>
            </div>
        </div>
	
		<div id="maintext">
		
			<h1>Abstract</h1>
						
			<h2>Content</h2>
			<ul class=content>
				<li class=ct1><a href="#p0">Introduction</a>
				<li class=ct1><a href="#p1">1. Theme urgency</a>
				<li class=ct1><a href="#p2">2. Goal and tasks of the research</a>
				<li class=ct1><a href="#p3">3. Database Fragmentation</a>
				<li class=ct1><a href="#p4">Conclusion</a>
				<li class=ct1><a href="#ref">References</a>
			</ul>
			
			<a name=p0></a>
			<h2>Introduction</h2>
			
			<p>Currently, no website or serious application can do without using databases. They are used for storing, organizing and grouping data, which ensures ease of access to data and the integrity of information. To create, manage, administer and use databases, specialized programs or groups of programs of the database management system (DBMS &ndash; Database Management System) are used.</p>
            
            <p>The development of the DBMS began in the mid 60-ies of the XX century in the development of space programs. The first full-fledged DBMS was the hierarchical IMS (Information Management System). This system today is also used as the main hierarchical DBMS on high-performance servers. IMS is a secure, reliable, high-throughput software for online transaction processing and batch processing.</p>
			
			
			<a name=p1></a>
			<h2>1. Theme urgency</h2>
			
			<p>With the advent of technically more complex software systems, the need for storing and processing large amounts of information increases in direct proportion. This leads to the fact that the amount of information stored in databases exceeds the physical limitations of centralized systems. As a result, reduced productivity, fault tolerance and compromised integrity of the stored information.</p>
            
            <p>In modern development approaches, decentralization processes are becoming increasingly important. Over the past decades, developers have sought to design geographically distributed databases. This approach allows you to increase database performance, improve the protection of stored information, provide effective means of data replication. However, to achieve the above advantages, it is necessary to apply effective methods for designing distributed databases.</p>
			
			<a name=p2></a>
			<h2>2. Goal and tasks of the research</h2>
			
			<p>The purpose of the study is to develop methods for designing a distributed database that can decentralize the database by breaking it into fragments. The resulting fragments will be placed in the nodes of the computer network. Based on the methods obtained, it is necessary to create algorithms for the software package, the results of which will increase the efficiency of processing requests to a distributed database, data replication, and protection of stored data.</p>
            
            <p>The main objectives of the study:</p>
            <ol>
                <li>Study of the characteristics of distributed data processing systems.
                <li>Studying the main tasks included in the design process of distributed databases.
                <li>Investigation of the problems of database fragmentation, placement of fragments in the nodes of a computer network.
                <li>Formation of a query execution strategy.
                <li>Selection and justification of the effectiveness criterion for a distributed database.
                <li>Development of algorithms that describe fragmentation and fragment placement methods. The formation of the architecture of a distributed database.
                <li>Implementation of a distributed database in a software package.
            </ol>
            
            <p><span class = itl>Research Object</span>: Distributed Database.</p>
            <p><span class = itl>Subject of research</span>: models and algorithms of the software package designed to describe the methodology of decentralization of the database.</p>
            
            <p>As part of the master's work, it is planned to obtain relevant <span class = itl>scientific results</span> in the following areas:</p>
            <ol>
                <li>Formation of the design task of a distributed database, taking into account the features of database fragmentation and placement of the resulting fragments.
                <li>Formation of a query execution strategy.
                <li>Selection and justification of a distributed database performance criterion that takes into account the influence of the physical parameters of the system on the speed of request processing and the transaction availability ratio.
            </ol>
            
            <p>As <span class = itl>practical results</span>, it is planned to develop a highly loaded distributed database and integrate it into a ready-made software package for online ticketing.</p>
			
			<a name=p3></a>
			<h2>3. Database Fragmentation</h2>
			
			
			<p>Database fragmentation, or sharding, is a database architecture pattern associated with horizontal partitioning (dividing the rows of one table into several different tables, called partitions). Each section has the same layout and columns, but different rows. Accordingly, the data stored in each of them is unique and does not depend on the data stored in other sections.</p>

            <p>It is customary to compare horizontal partitioning with vertical. In a table with vertical partitioning, entire columns are separated and placed in separate tables. The data contained in one vertical section does not depend on the data in all other such sections; each of them contains both separate rows and separate columns. Figure 1 shows the horizontal and vertical partitioning of a table.</p>

            <div class=img>
                <img src="images/animation.gif" alt="The process of horizontal and vertical table partitioning">
                <p class=imgcaption>Figure 1 &ndash; The process of horizontal and vertical table partitioning</p>
            </div>

			<p>Fragmentation involves splitting data into two or more smaller parts called logical segments. Then they are distributed over individual database nodes, the so-called physical segments, which can contain several logical segments. The data stored in all segments represents a whole set of logical data.</p>
            
            <p>A segmented database is an example of a shared architecture. This means that all segments are autonomous; they do not use the same data or computing resources. In some cases, however, it may make sense to copy specific tables to each segment to use for reference. For example, there is a database for the application, which depends on fixed conversion factors for weight measurements. By replicating a table containing the necessary data on the conversion rate to each segment, it is possible to provide each segment with all the data necessary for the queries.</p>
            
            <p>Often fragmentation is implemented at the application level, that is, the application includes code that determines which segment to transmit for reading and writing. However, some database management systems have built-in fragmentation capabilities, which allows it to be implemented directly at the database level.</p>
            
            <h3>4.1 Benefits of database fragmentation</h3>
            
            <p>The main advantage of sharding is that it can simplify scaling out. Horizontal scaling is the addition of new machines to the existing stack, which allows you to distribute the load and process more traffic faster. This practice is often compared to scaling up, which involves updating the hardware of an existing server, usually by adding more RAM or CPU.</p>
            <p>Maintaining a relational database running on the same machine, and scaling it vertically as needed, updating its computing resources, is relatively simple. However, in the end, any non-segmented database will be limited in terms of storage and processing power, so the ability to scale horizontally makes your installation much more flexible.</p>
            <p>Another reason why some people choose the architecture of a fragmented database is to reduce the response time of the request. When sending a query to a non-fragmented database, a search is performed on each row in the table before a set of the desired results is found. In an application with a large monolithic database, queries can be processed very slowly. In a segmented table, fewer rows are searched while searching, and results are returned much faster.</p>
            <p>Fragmentation can also make an application more reliable by mitigating the effects of crashes. If your application or website uses a monolithic database, a failure may result in the unavailability of the entire application. However, when using a fragmented database, disconnection can affect only one data segment. Some parts of the application or website may become inaccessible, but the overall impact will still be less than if the entire database crashed.</p>
            
            <h3>4.2 Disadvantages of database fragmentation</h3>

            <p>Although database fragmentation can simplify scaling and improve performance, it can also impose certain limitations. In this section, we will discuss some of these limitations and situations in which it is better not to use sharding at all.</p>

            <p>The first problem that people face when using fragmentation is the difficulty of correctly implementing such an architecture. Incorrectly fragmented data can lead to data loss or damage to tables. But even if everything is done correctly, fragmentation can have a significant impact on your team’s workflows. Instead of accessing and managing data from one point, team members will have to manage data in several segments, which may interfere with the work of some groups.</p>

			<p>The problem that is sometimes encountered after database fragmentation is that the segments ultimately vary greatly in size. Suppose you have a database with two separate segments: one for customers whose last names begin with letters from A to M, and the second for those whose last names begin with letters from N to Z. However, the application serves a lot of users whose last names begin with the letter G. Accordingly, the first segment gradually accumulates more data than the second. This slows down the application while serving a significant portion of your users. In this case, any of the benefits of database fragmentation is negated by slowdowns and crashes. Most likely, the database will need to be restored and reconfigured to ensure more even distribution of data.</p>
            <p>Another significant drawback is that after fragmenting the database, it can be very difficult to return it to the previous architecture. Database backups made before fragmentation do not contain data recorded after fragmentation. Therefore, to restore the original architecture, it will be necessary to combine the new segmented data with the old backups or, conversely, convert the segmented database back to a single database, which will be time consuming and expensive.</p>
            
            <h3>4.3 Views of fragmented architectures</h3>

            <p>When executing queries or distributing incoming data into segmented tables or databases, it is important that they are transferred to the correct segment. Otherwise, this can lead to data loss or extremely slow query processing. In this section, we will look at several common fragmentation architectures, each of which uses a slightly different process to distribute data between segments.</p>

            <h3>4.3.1 Interval Fragmentation</h3>

            <p>Interval fragmentation involves segmenting data based on ranges of a given value. Suppose you have a database that stores information about all the products in a catalog. You can create several different segments and separate information about each product depending on the price range into which they fall (Figure 2).</p>

            <div class=img>
                <img src="images/diagram1.jpg" alt="Interval Fragmentation Example">
                <p class=imgcaption>Figure 2 &ndash; Interval Fragmentation Example</p>
            </div>

            <p>The main advantage of this model is that it is relatively easy to implement. Each segment contains a different set of data, but they all have the same design as well as the original database. The application code simply reads into which range the data falls and writes it to the corresponding fragment.</p>

            <p>On the other hand, interval segmentation does not protect the data from uneven distribution, which leads to the aforementioned hotspots. Figure 2 shows that even if each shard contains the same amount of data, it is likely that specific products will receive more attention than others. And the corresponding segments, in turn, will receive a disproportionate number of read operations.</p>

            <h3>4.3.2 Directory Fragmentation</h3>

            <p>To implement this model, you need to create and maintain a lookup table that, with the help of a segment key, keeps track of what data is contained in a particular segment. In this context, a look-up table is a table that contains a static set of information about where specific data can be found. Figure 3 shows a simplified example of directory segmentation.</p>

            <div class=img>
                <img src="images/diagram2.jpg" alt="Directory segmentation example">
                <p class=imgcaption>Figure 3 &ndash; Directory segmentation example</p>
            </div>

            <p>Here, the Delivery Zone column is defined as a segment key. The data from the segment key is written to the look-up table along with the segment into which each corresponding row should be written. This is similar to interval segmentation, but instead of defining the range into which the data falls, each key is bound to its specific segment. Catalog segmentation is better than interval segmentation in cases where a segment key has a low communication power, it makes no sense to store a range of keys for a segment. Please note that this model also differs from key segmentation, as it does not process the segment key with a hash function; she just checks the key against the table to see where to write the data.</p>
            <p>The main advantage of directory fragmentation is flexibility. Interval segmentation architecture limits users to ranges of values, and key architecture with a fixed hash function, which, as mentioned earlier, can subsequently be extremely difficult to change. Catalog segmentation allows you to use any system or algorithm to enter data into segments, and using this approach it is relatively easy to dynamically add fragments.</p>
            <p>Directory segmentation is the most flexible of the methods discussed here, but the need to connect to a table before each query or record can adversely affect application performance. In addition, the lookup table can become a single point of failure: if it is damaged or otherwise malfunctioning, this will affect the ability to write or retrieve data.</p>

			<a name=p4></a>
			<h2>Conclusion</h2>
			<p>In the framework of this work, the main ways of segmenting the database were considered, the features of each of the methods were identified. In the future, it is planned to use one of the described methods of database segmentation as part of the ongoing project for online ticketing.</p>
            <p>The master's thesis is devoted to the urgent scientific task of researching methods for creating productive DBMS. As part of the research performed:</p>
            <ol>
                <li>Methods of database fragmentation are considered.
                <li>Based on the analysis of literary sources, the structure of building productive DBMSs is highlighted.
                <li>The requirements for a productive DBMS were formed and analyzed.
                <li>Formation of a query execution strategy.
                <li>Selection and justification of the effectiveness criterion for a distributed database.
                <li>Development of algorithms that describe fragmentation and fragment placement methods. The formation of the architecture of a distributed database.
                <li>Implementation of a distributed database in a software package.
            </ol>
            <p>Further research focuses on the following steps:</p>
            <ol>
                <li>Design and implementation of a distributed database, taking into account the features of database fragmentation.
                <li>Formation of a query execution strategy.
                <li>Justification of the selected criteria for the effectiveness of a distributed database.
            </ol>
                    
            <p>When writing this essay, the master's work is not yet completed. Final completion: June 2020. Full text of the work
            and materials on the topic can be obtained from the author or his manager after the specified date.</p>
			
			<a name=ref></a>
			<h2>References</h2>
            <ol>
                <li><a name="ref1"></a>Codd E.F. A Relational Model of Data for Large Shared Data Banks &ndash; Journal <q>Communications of the ACM</q>, Vol. 13, no. 6., 1970, pp. 377—387.
                <li><a name="ref2"></a>Berri C. A sophisticates introduction to database normalization theory &ndash; 4th Conf. of Very Large Databases, 1978, pp. 113-124.
                <li><a name="ref3"></a>Thalheim B. The HERM Algebra &ndash; Book <q>Entity-Relationship Modeling: Foundations of Database Technology Reading</q>, Department of Computer Science Brandenburg University of Technology, Germany, 2013, pp. 223-244.
                <li><a name="ref4"></a>Gurevich Yu. Logic and the challenge of computer science &ndash; Current Trends in Theoretical Computer Science (Borger E). Computer Science Press, 1988, pp. 1–57.
            </ol>
		
		</div> <!-- maintext -->
	
	</div> <!-- middleblock -->

	<div id="menub">
		<a class="mitemb" href="../indexe.html">Resume</a>
	</div>

</body>
</html>
